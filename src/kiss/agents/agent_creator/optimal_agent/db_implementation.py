"""
Database Implementation Templates

This module contains the actual bash script implementations
that the agent will generate for the database engine.
"""

DB_SCRIPT_TEMPLATE = '''#!/bin/bash
# Bash-based Database Engine with Transactions and Concurrency Control
# Generated by Database Engine Agent

set -euo pipefail

# Configuration
DB_DIR="./my_db"
LOCK_DIR="$DB_DIR/.lock"
TRANSACTION_DIR="$DB_DIR/.transactions"
SESSION_ID="$$"

# Initialize database directory structure
init_db() {
    mkdir -p "$DB_DIR"
    mkdir -p "$TRANSACTION_DIR"
}

# Acquire global lock using mkdir (atomic operation)
acquire_lock() {
    local lock_acquired=0
    local retries=0
    local max_retries=100

    while [ $lock_acquired -eq 0 ] && [ $retries -lt $max_retries ]; do
        if mkdir "$LOCK_DIR" 2>/dev/null; then
            lock_acquired=1
            echo $SESSION_ID > "$LOCK_DIR/owner"
        else
            sleep 0.01
            retries=$((retries + 1))
        fi
    done

    if [ $lock_acquired -eq 0 ]; then
        echo "Failed to acquire lock after $max_retries attempts" >&2
        exit 1
    fi
}

# Release global lock
release_lock() {
    if [ -d "$LOCK_DIR" ]; then
        rm -rf "$LOCK_DIR"
    fi
}

# Set a key-value pair
db_set() {
    local key="$1"
    local value="$2"

    # Validate key (alphanumeric and underscore only)
    if ! [[ "$key" =~ ^[a-zA-Z0-9_]+$ ]]; then
        echo "Invalid key: $key" >&2
        exit 1
    fi

    if [ -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        # In transaction - write to transaction file
        echo "SET $key $value" >> "$TRANSACTION_DIR/$SESSION_ID"
    else
        # Not in transaction - write directly with locking
        acquire_lock
        echo "$value" > "$DB_DIR/$key"
        release_lock
    fi
}

# Get value for a key
db_get() {
    local key="$1"

    # Check transaction cache first
    if [ -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        # Search transaction log in reverse for most recent value
        local tx_value
        tx_value=$(tac "$TRANSACTION_DIR/$SESSION_ID" | grep "^SET $key " | head -n1 | cut -d" " -f3-)

        if [ -n "$tx_value" ]; then
            echo "$tx_value"
            return 0
        fi

        # Check if deleted in transaction
        if tac "$TRANSACTION_DIR/$SESSION_ID" | grep -q "^DELETE $key$"; then
            echo "Key not found: $key" >&2
            exit 1
        fi
    fi

    # Read from main storage
    if [ -f "$DB_DIR/$key" ]; then
        cat "$DB_DIR/$key"
    else
        echo "Key not found: $key" >&2
        exit 1
    fi
}

# Delete a key
db_delete() {
    local key="$1"

    if [ -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        # In transaction - write to transaction file
        echo "DELETE $key" >> "$TRANSACTION_DIR/$SESSION_ID"
    else
        # Not in transaction - delete directly with locking
        acquire_lock
        if [ -f "$DB_DIR/$key" ]; then
            rm "$DB_DIR/$key"
        fi
        release_lock
    fi
}

# Begin a transaction
db_begin() {
    if [ -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        echo "Transaction already in progress" >&2
        exit 1
    fi

    touch "$TRANSACTION_DIR/$SESSION_ID"
}

# Commit a transaction
db_commit() {
    if [ ! -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        echo "No transaction in progress" >&2
        exit 1
    fi

    # Acquire lock for atomic commit
    acquire_lock

    # Apply all operations from transaction log
    while IFS= read -r line; do
        local op
        op=$(echo "$line" | cut -d" " -f1)
        local key
        key=$(echo "$line" | cut -d" " -f2)

        if [ "$op" = "SET" ]; then
            local value
            value=$(echo "$line" | cut -d" " -f3-)
            echo "$value" > "$DB_DIR/$key"
        elif [ "$op" = "DELETE" ]; then
            if [ -f "$DB_DIR/$key" ]; then
                rm "$DB_DIR/$key"
            fi
        fi
    done < "$TRANSACTION_DIR/$SESSION_ID"

    # Clean up transaction file
    rm "$TRANSACTION_DIR/$SESSION_ID"

    release_lock
}

# Rollback a transaction
db_rollback() {
    if [ ! -f "$TRANSACTION_DIR/$SESSION_ID" ]; then
        echo "No transaction in progress" >&2
        exit 1
    fi

    # Simply remove transaction file
    rm "$TRANSACTION_DIR/$SESSION_ID"
}

# Main command dispatcher
main() {
    init_db

    local command="${1:-}"

    case "$command" in
        set)
            if [ $# -ne 3 ]; then
                echo "Usage: $0 set <key> <value>" >&2
                exit 1
            fi
            db_set "$2" "$3"
            ;;
        get)
            if [ $# -ne 2 ]; then
                echo "Usage: $0 get <key>" >&2
                exit 1
            fi
            db_get "$2"
            ;;
        delete)
            if [ $# -ne 2 ]; then
                echo "Usage: $0 delete <key>" >&2
                exit 1
            fi
            db_delete "$2"
            ;;
        begin)
            db_begin
            ;;
        commit)
            db_commit
            ;;
        rollback)
            db_rollback
            ;;
        *)
            echo "Usage: $0 {set|get|delete|begin|commit|rollback}" >&2
            echo "  set <key> <value>  - Set a key-value pair" >&2
            echo "  get <key>          - Get value for key" >&2
            echo "  delete <key>       - Delete a key" >&2
            echo "  begin              - Begin transaction" >&2
            echo "  commit             - Commit transaction" >&2
            echo "  rollback           - Rollback transaction" >&2
            exit 1
            ;;
    esac
}

main "$@"
'''

STRESS_TEST_TEMPLATE = '''#!/bin/bash
# Stress Test for Database Engine
# Tests concurrency with multiple processes

set -euo pipefail

DB_SCRIPT="./db.sh"
NUM_PROCESSES=10
OPS_PER_PROCESS=100
FAILED_OPS=0

# Cleanup function
cleanup() {
    echo "Cleaning up..."
    rm -rf ./my_db
}

# Test function run by each process
test_process() {
    local proc_id=$1
    local errors=0

    for i in $(seq 1 $OPS_PER_PROCESS); do
        local key="key_${proc_id}_${i}"
        local value="value_${proc_id}_${i}"

        # Set operation
        if ! "$DB_SCRIPT" set "$key" "$value" 2>/dev/null; then
            errors=$((errors + 1))
            continue
        fi

        # Get operation
        local retrieved
        if ! retrieved=$("$DB_SCRIPT" get "$key" 2>/dev/null); then
            errors=$((errors + 1))
            continue
        fi

        # Verify value
        if [ "$retrieved" != "$value" ]; then
            echo "ERROR: Value mismatch for $key" >&2
            errors=$((errors + 1))
        fi

        # Delete operation (optional)
        if [ $((i % 3)) -eq 0 ]; then
            "$DB_SCRIPT" delete "$key" 2>/dev/null || true
        fi
    done

    echo "$errors" > "/tmp/stress_test_errors_${proc_id}"
}

# Test transaction atomicity
test_transaction() {
    echo "Testing transaction atomicity..."

    # Begin transaction
    "$DB_SCRIPT" begin

    # Set multiple values
    "$DB_SCRIPT" set "tx_key1" "tx_value1"
    "$DB_SCRIPT" set "tx_key2" "tx_value2"

    # Commit
    "$DB_SCRIPT" commit

    # Verify values
    local val1 val2
    val1=$("$DB_SCRIPT" get "tx_key1")
    val2=$("$DB_SCRIPT" get "tx_key2")

    if [ "$val1" = "tx_value1" ] && [ "$val2" = "tx_value2" ]; then
        echo "Transaction test PASSED"
        return 0
    else
        echo "Transaction test FAILED"
        return 1
    fi
}

# Test rollback
test_rollback() {
    echo "Testing rollback..."

    # Set initial value
    "$DB_SCRIPT" set "rollback_key" "initial_value"

    # Begin transaction and modify
    "$DB_SCRIPT" begin
    "$DB_SCRIPT" set "rollback_key" "modified_value"

    # Rollback
    "$DB_SCRIPT" rollback

    # Verify original value preserved
    local val
    val=$("$DB_SCRIPT" get "rollback_key")

    if [ "$val" = "initial_value" ]; then
        echo "Rollback test PASSED"
        return 0
    else
        echo "Rollback test FAILED"
        return 1
    fi
}

# Main test execution
main() {
    echo "Starting Database Stress Test"
    echo "=============================="
    echo "Processes: $NUM_PROCESSES"
    echo "Operations per process: $OPS_PER_PROCESS"
    echo ""

    # Cleanup before test
    cleanup

    # Run transaction tests
    if ! test_transaction; then
        echo "Transaction test failed!"
        exit 1
    fi

    if ! test_rollback; then
        echo "Rollback test failed!"
        exit 1
    fi

    # Launch concurrent processes
    echo "Launching $NUM_PROCESSES concurrent processes..."

    local pids=()
    for i in $(seq 1 $NUM_PROCESSES); do
        test_process $i &
        pids+=($!)
    done

    # Wait for all processes
    echo "Waiting for processes to complete..."
    for pid in "${pids[@]}"; do
        wait "$pid"
    done

    # Count total errors
    local total_errors=0
    for i in $(seq 1 $NUM_PROCESSES); do
        if [ -f "/tmp/stress_test_errors_${i}" ]; then
            local proc_errors
            proc_errors=$(cat "/tmp/stress_test_errors_${i}")
            total_errors=$((total_errors + proc_errors))
            rm "/tmp/stress_test_errors_${i}"
        fi
    done

    # Report results
    echo ""
    echo "=============================="
    echo "Stress Test Results"
    echo "=============================="
    echo "Total operations: $((NUM_PROCESSES * OPS_PER_PROCESS))"
    echo "Failed operations: $total_errors"
    echo "Success rate: $(awk "BEGIN {printf \\"%.2f\\", (1 - $total_errors/($NUM_PROCESSES * $OPS_PER_PROCESS)) * 100}")%"

    if [ $total_errors -eq 0 ]; then
        echo ""
        echo "✓ ALL TESTS PASSED"
        cleanup
        exit 0
    else
        echo ""
        echo "✗ SOME TESTS FAILED"
        exit 1
    fi
}

main "$@"
'''


def get_db_script() -> str:
    """Get the database script implementation"""
    return DB_SCRIPT_TEMPLATE


def get_stress_test_script() -> str:
    """Get the stress test script implementation"""
    return STRESS_TEST_TEMPLATE


def generate_readme() -> str:
    """Generate README for the database engine"""
    return """# Bash Database Engine

A robust database engine implemented entirely in Bash with transaction support
and concurrency control.

## Features

- **Basic Operations**: set, get, delete
- **Transactions**: begin, commit, rollback
- **Concurrency**: mkdir-based mutex locking
- **Atomicity**: All-or-nothing transaction commits
- **Safety**: No corruption under concurrent access

## Usage

### Basic Operations

```bash
# Set a key-value pair
./db.sh set mykey myvalue

# Get a value
./db.sh get mykey

# Delete a key
./db.sh delete mykey
```

### Transactions

```bash
# Begin transaction
./db.sh begin

# Make changes (not visible to others yet)
./db.sh set key1 value1
./db.sh set key2 value2

# Commit changes atomically
./db.sh commit

# Or rollback to discard changes
./db.sh rollback
```

## Testing

Run the stress test to verify concurrency:

```bash
./test_stress.sh
```

This launches 10 concurrent processes performing 100 operations each,
verifying no data corruption occurs.

## Architecture

- **Data Storage**: `./my_db/` directory with one file per key
- **Locking**: mkdir-based atomic locking (`./my_db/.lock/`)
- **Transactions**: Per-session logs in `./my_db/.transactions/`

## Implementation Details

### Locking Mechanism

Uses `mkdir` which is atomic on most filesystems. Each process attempts
to create the lock directory, retrying with exponential backoff if locked.

### Transaction Isolation

Each transaction maintains a session-specific log file. On commit, the log
is replayed atomically under global lock. On rollback, the log is simply deleted.

### Concurrency Safety

The global lock ensures that:
1. Direct operations (outside transactions) are atomic
2. Transaction commits are atomic
3. No partial state is visible to readers

## Requirements

- Bash 4.0+
- Standard Unix utilities (mkdir, rm, cat, etc.)
- POSIX-compliant filesystem

## License

MIT License
"""


if __name__ == "__main__":
    # Example: Generate scripts
    print("Database Implementation Templates")
    print("=" * 60)
    print("\nUse get_db_script() and get_stress_test_script()")
    print("to retrieve the implementation templates.")
